<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Varient and Constant</title>
    <style>
         table{
            border-collapse: collapse;
        }
        caption, th {
            border: 1px solid #ccc;
            text-align: center;
        }
        td {
            border: 1px solid #ccc;
            text-align: left;
        }
    </style>
</head>
<body>
    <h1>변수와 상수</h1>
    <p>프로그래밍 언어를 공부할 때 가장 먼저 배우는 개념은 '데이터 처리'이다. 데이터를 처리하려면 데이터를 저장할 공간이 필요한데, 자바스크립트에서는 데이터를 저장하는 공간을 <strong>변수</strong>와 <strong>상수</strong>라고 한다.</p>
    <br>
    <h2>변수 (varient)</h2>
    <p>값이 변하는 데이터를 저장하고 관리하기 위한 공간으로, 자바스크립트에서는 변수를 만든다.</p>
    <fieldset>
        <legend>변수 문법</legend>
        <p>
            var num = 10 + 20;<br>
            (키워드) (식별자) (연산자) (표현식);
        </p>
    </fieldset>
    <h3>키워드(keyword)</h3>
    <p>키워드란 자바스크립트 프로그래밍 언어에서 어떤 역할이나 기능이 정해진 특별한 단어다. 다른 용어로는 예약어(reserved word)라고도 한다.</p>
    <h3>식별자(identifier)</h3>
    <p>식별자는 자바스크립트 내부에서 변수, 함수 등에 부여되는 이름을 의미한다. 변수는 컴퓨터의 메모리라는 곳에 저장되는데, 메모리가 굉장히 추상적이기 때문에 사람이 이해하고 사용하기 쉽게 특정 공간을 식별할 수 있는 식별자를 사용해 나타낸다.<br> 식별자는 앞에 사용된 키워드의 역할에 따라 다르게 부르기도 하는데, 예를 들어 변수를 생성하는 var, let, const 등의 키워드와 함께 사용하면 식별자라는 용어보다는 <strong>변수명</strong>이라는 용어로 더 자주 불린다.</p>
    <h3>연산자(operator)</h3>
    <p>연산자는 이름 그대로 어떠한 연산 작업을 하는 데 사용하는 기호다.</p>
    <h3>표현식(expression)</h3>
    <p>표현식이란 평가(evaluation, 표현식을 실행해 하나의 값을 만드는 과정)되어 하나의 값을 반환하는 식 또는 코드를 의미한다.</p>
    <h3>값(value)</h3>
    <p>값은 더 이상 평가할 수 없는 데이터를 의미한다.</p>
    <h3>세미콜론(;, semicolon)</h3>
    <p>세미콜론은 자바스크립트에서 하나의 문(statement, 문법)이 끝났음을 의미한다. 프로그래밍 언어는 컴퓨터에게 명령 또는 연산을 수행하게 할 목적의 언어이고, 자바스크립트 문법은 1개의 명령을 하나의 문법이라고 보기 때문에 세미콜론을 붙여 하나의 명령문이 끝났음을 명시적으로 표현해주는 것이 좋다.</p>
    <h3>★ 선언, 할당, 초기화</h3>
    <p>변수를 생성하고 값을 저장하는 문법에서 var 키워드 이후에 배우는 let, const 키워드를 사용해 변수의 식별자를 지정하는 행위를 <strong>변수를 선언한다</strong>라고 한다. 그리고 할당 연산자인 = 기호로 우변에 있는 값을 변수 공간에 대입(저장)하는 것을 <strong>값을 할당한다</strong>고 한다.</p>
    <p>변수는 초기에 값을 꼭 할당하지 않아도 된다. 즉, 아래의 예시처럼 선언만 할 수도 있다.</p>
    <fieldset>
        <p>var num;</p>
    </fieldset>
    <p>선언과 할당을 같이 하는 것은 <strong>변수를 초기화한다</strong>고 한다.</p>
    <br>
    <h2>변수 선언 키워드 let</h2>
    <p>변수를 선언하는 키워드는 var 이외에 let을 사용할 수 있다. 얼핏 var와 let은 같은 역할을 하는 것처럼 보이지만, let은 var키워드보다 여러 기능이 개선되었다.</p>
    <h3>1. 변수명 중복이 불가능하다.</h3>
    <fieldset>
        <legend>var 키워드 -> 중복 가능</legend>
        <p>
            var num = 10 + 20;<br>
            var num = 50;
        </p>
    </fieldset>
    <fieldset>
        <legend>let 키워드 -> 중복 불가</legend>
        <p>
            let num = 10 + 20; <br>
            let num = 50;
        </p>
        <p>이 경우 정상적으로 실행되지 않으며, 이미 num 식별자가 선언되었다는 오류 메시지가 발생한다.</p> 
    </fieldset>
    <p>let 키워드는 중복 선언을 불가능하게 함으로써, 다른 사람이 선언한 변수명을 실수로 재선언하는 등의 사고를 방지한다.</p>
    <h3>2. 호이스팅되지 않는다.</h3>
    <p>호이스팅이란 var 키워드로 변수를 선언하고 할당했을 때, 변수 선언을 자바스크립트의 스코프 맨 위로 올려 실행하는 것을 말한다.</p>
    <fieldset>
        <legend>호이스팅 예시</legend>
        <table>
            <tr>
                <th>작성 코드</th>
                <th>실제 적용되는 모습</th>
            </tr>
            <tr>
                <td>
                    console.log(num);<br>
                    var num = 10;
                </td>
                <td>
                    var num; //선언이 최상위로 올라옴<br>
                    console.log(num);<br>
                    num = 10; //할당은 원래 자리에 있음
                </td>
            </tr>
            <tr>
                <td colspan="2">결과 : undefined</td>
            </tr>
        </table>
        <p>호이스팅에 의해 출력 이후 선언된 var 키워드의 선언부가 최상위로 올라간다. 그래서 num이라는 변수를 출력할 때는, 값이 없을 뿐 선언이 된 상태라 오류가 발생하지 않는다.</p>
    </fieldset>
    <p>그러나 let 키워드는 이런 호이스팅이 발생하지 않아, 위와 같은 원치 않은 오류를 막아준다.</p>
    <fieldset>
        <legend>호이스팅 방지</legend>
        <table>
            <tr>
                <th>작성코드</th>
                <td>
                    console.log(num);<br>
                    let num = 10;
                </td>
            </tr>
            <tr>
                <th>결과</th>
                <td>
                    Uncaught ReferenceError : num is not defined
                </td>
            </tr>
        </table>
    <p>undefined값이 출력되지 않고, num이라는 변수가 정의되지 않았다는 오류메시지가 발생한다.</p>
    </fieldset>
    <h3>3. 스코프의 범위가 다르다.</h3>
    <p>var 키워드와 let 키워드는 참조하는 스코프가 조금 다르다. 이 차이점 때문에 실무에서는 되도록 let 키워드로 선언하기를 권장한다. (일부 웹 브라우저에서는 완벽하게 지원하지 않음에도 불구하고 let을 권장한다.)</p>
    <br>
    <h2>상수 (constant)</h2>
    <p>const라는 키워드로도 변수를 선언할 수 있다. 기본적으로는 let 키워드처럼 변수명을 중복으로 선언할 수 없고, 호이스팅이 되지 않으며, 스코프에도 차이가 있다. const가 let과 다른 점은 <strong>재할당이 되지 않는다</strong>는 점이다.</p>
    <fieldset>
        <legend>재할당 예시</legend>
        <table>
            <tr>
                <th>작성코드</th>
                <th>결과</th>
                
            </tr>
            <tr>
                <td>
                    <strong>let</strong> num = 10;<br>
                    num = 30;<br>
                    console.log(num);<br>
                </td>
                <td>
                    30
                </td>
            </tr>
            <tr>
                <td>
                    <strong>const</strong> num = 10;<br>
                    num = 30;<br>
                    console.log(num);<br>
                </td>
                <td>
                    Uncaught TypeError : Assignment to constant variable.
                </td>
            </tr>
        </table>
        <p>var, let 키워드와는 달리 const 키워드는 재할당이 되지 않음(오류 뜸)</p>
    </fieldset>
    <p>재할당이 되지 않기 때문에, 선언을 먼저 하고 할당을 나중에 하는 것도 안된다.</p>
    <fieldset>
        <legend>선언 후 할당</legend>
        <table>
            <tr>
                <th>작성코드</th>
                <th>결과</th>
                
            </tr>
            <tr>
                <td>
                    <strong>const</strong> num;<br>
                    num = 10;
                </td>
                <td>
                    Uncaught SyntaxError : Missing initializer in const declaration
                </td>
            </tr>
        </table>
    </fieldset>
    <br>
    <h2>식별자 명명 규칙</h2>
    <p>변수나 상수를 선언하고 식별자를 지정할 때 몇 가지 규칙이 있다. 이 규칙은 강제적인 차원의 것도 있고, 관용적인 차원의 것도 있는데 강제 규칙은 지키지 않을 경우 오류가 발생하므로 주의해야 한다.</p>
    <fieldset>
        <legend>강제적 식별자 명명 규칙</legend>
        <table>
            <tr>
                <th>규칙</th>
                <th>불가능 예</th>
            </tr>
            <tr>
                <td>식별자에 키워드 사용 불가</td>
                <td>var, let, const</td>
            </tr>
            <tr>
                <td>식별자에 공백 포함 불가</td>
                <td>my School, like food</td>
            </tr>
            <tr>
                <td>식별자의 첫 글자는 영문 소문자, _(언더스코어), $기호만 사용</td>
                <td>*name, #age, @email</td>
            </tr>
        </table>
    </fieldset>
    <fieldset>
        <legend>관용적 식별자 명명 규칙</legend>
        <table>
            <tr>
                <th>규칙</th>
                <th>좋은 예</th>
                <th>나쁜 예</th>
            </tr>
            <tr>
                <td>식별자는 영문으로만 작성</td>
                <td>name, age</td>
                <td>이름, 나이</td>
            </tr>
            <tr>
                <td>식별자는 의미 있는 단어로 작성</td>
                <td>name, age(이름과 나이 저장 시)</td>
                <td>a, b(이름과 나이 저장 시)</td>
            </tr>
        </table>
    </fieldset>
    <p>이런 관용 규칙은 되도록 지키는 것이 좋다.</p>
    <h3>식별자 표기법</h3>
    <p>
        1) camelCase -> 변수명과 함수명 작성 시 사용<br>
        2) snake_case -> 상수명 작성 시 사용<br>
        3) PascalCase -> 생성자 함수 작성 시 사용<br>
    </p>
    <br>
    <p>-------------</p>
    let score = 10;
</body>
</html>